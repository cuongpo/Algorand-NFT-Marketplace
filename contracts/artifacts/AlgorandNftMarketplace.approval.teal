#pragma version 9

// This TEAL was generated by TEALScript v0.63.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// createCollection(string)void
abi_route_createCollection:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createCollection(string)void
	callsub createCollection
	int 1
	return

createCollection:
	proto 2 0

	// contracts/algorand_nft_marketplace.algo.ts:37
	// temp: collectionData = {
	//       name: name,
	//       owner: this.txn.sender,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	txn Sender
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury -2 // temp: collectionData

	// contracts/algorand_nft_marketplace.algo.ts:42
	// this.collection(this.collectionIndex.value).value = temp
	byte 0x636f6c6c656374696f6e496e646578 // "collectionIndex"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig -2 // temp: collectionData
	box_put

	// contracts/algorand_nft_marketplace.algo.ts:43
	// this.collectionIndex.value = this.collectionIndex.value + 1
	byte 0x636f6c6c656374696f6e496e646578 // "collectionIndex"
	byte 0x636f6c6c656374696f6e496e646578 // "collectionIndex"
	app_global_get
	int 1
	+
	app_global_put
	retsub

// mintNFT(string,string)uint64
abi_route_mintNFT:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// url: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute mintNFT(string,string)uint64
	callsub mintNFT
	int 1
	return

mintNFT:
	proto 3 0

	// contracts/algorand_nft_marketplace.algo.ts:47
	// nftTicket = sendAssetCreation({
	//       configAssetTotal: 1,
	//       configAssetName: name,
	//       configAssetURL: url,
	//     })
	itxn_begin
	int acfg
	itxn_field TypeEnum

	// contracts/algorand_nft_marketplace.algo.ts:48
	// configAssetTotal: 1
	int 1
	itxn_field ConfigAssetTotal

	// contracts/algorand_nft_marketplace.algo.ts:49
	// configAssetName: name
	frame_dig -1 // name: string
	itxn_field ConfigAssetName

	// contracts/algorand_nft_marketplace.algo.ts:50
	// configAssetURL: url
	frame_dig -2 // url: string
	itxn_field ConfigAssetURL

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury -3 // nftTicket: asset

	// contracts/algorand_nft_marketplace.algo.ts:52
	// return nftTicket;
	frame_dig -3 // nftTicket: asset
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// mapNFTdata(uint64,asset)void
abi_route_mapNFTdata:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// collectionId: uint64
	txna ApplicationArgs 2
	btoi

	// nft: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute mapNFTdata(uint64,asset)void
	callsub mapNFTdata
	int 1
	return

mapNFTdata:
	proto 3 0

	// contracts/algorand_nft_marketplace.algo.ts:56
	// temp: nftData = {
	//       collectionId: collectionId,
	//       nftAsset: nft,
	//     }
	frame_dig -2 // collectionId: uint64
	itob
	frame_dig -1 // nft: asset
	itob
	concat
	frame_bury -3 // temp: nftData

	// contracts/algorand_nft_marketplace.algo.ts:61
	// this.nftDataMap(this.nftIndex.value).value = temp
	byte 0x6e // "n"
	byte 0x6e6674496e646578 // "nftIndex"
	app_global_get
	itob
	concat
	frame_dig -3 // temp: nftData
	box_put

	// contracts/algorand_nft_marketplace.algo.ts:62
	// this.nftIndex.value = this.nftIndex.value + 1
	byte 0x6e6674496e646578 // "nftIndex"
	byte 0x6e6674496e646578 // "nftIndex"
	app_global_get
	int 1
	+
	app_global_put
	retsub

// listingNFT(axfer,uint64,asset)void
abi_route_listingNFT:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// axfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==
	assert

	// price: uint64
	txna ApplicationArgs 2
	btoi

	// nft: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute listingNFT(axfer,uint64,asset)void
	callsub listingNFT
	int 1
	return

listingNFT:
	proto 4 0

	// contracts/algorand_nft_marketplace.algo.ts:67
	// verifyTxn(axfer, { assetReceiver: this.app.address })
	// verify assetReceiver
	frame_dig -3 // axfer: axfer
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/algorand_nft_marketplace.algo.ts:70
	// temp: orderData = {
	//       owner: this.txn.sender,
	//       price: price,
	//       nft: nft,
	//       status: 0,
	//     }
	txn Sender
	frame_dig -2 // price: uint64
	itob
	concat
	frame_dig -1 // nft: asset
	itob
	concat
	byte 0x0000000000000000
	concat
	frame_bury -4 // temp: orderData

	// contracts/algorand_nft_marketplace.algo.ts:77
	// this.order(this.orderIndex.value).value = temp
	byte 0x6f // "o"
	byte 0x6f72646572496e646578 // "orderIndex"
	app_global_get
	itob
	concat
	frame_dig -4 // temp: orderData
	box_put

	// contracts/algorand_nft_marketplace.algo.ts:78
	// this.orderIndex.value = this.orderIndex.value + 1
	byte 0x6f72646572496e646578 // "orderIndex"
	byte 0x6f72646572496e646578 // "orderIndex"
	app_global_get
	int 1
	+
	app_global_put
	retsub

// unListingNFT(asset,uint64)void
abi_route_unListingNFT:
	// nft: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute unListingNFT(asset,uint64)void
	callsub unListingNFT
	int 1
	return

unListingNFT:
	proto 2 0

	// contracts/algorand_nft_marketplace.algo.ts:83
	// assert(this.txn.sender === this.order(orderId).value.owner)
	txn Sender
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 0 32
	==
	assert

	// contracts/algorand_nft_marketplace.algo.ts:86
	// assert(this.order(orderId).value.status === 1)
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 48 8
	btoi
	int 1
	==
	assert

	// contracts/algorand_nft_marketplace.algo.ts:88
	// this.order(orderId).value.status = 1
	int 48
	byte 0x0000000000000001
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/algorand_nft_marketplace.algo.ts:91
	// sendAssetTransfer({
	//       xferAsset: nft,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: 1,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/algorand_nft_marketplace.algo.ts:92
	// xferAsset: nft
	frame_dig -2 // nft: asset
	itxn_field XferAsset

	// contracts/algorand_nft_marketplace.algo.ts:93
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/algorand_nft_marketplace.algo.ts:94
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// buyNFTFromMarketplace(asset,pay,uint64)void
abi_route_buyNFTFromMarketplace:
	// nft: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// payment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute buyNFTFromMarketplace(asset,pay,uint64)void
	callsub buyNFTFromMarketplace
	int 1
	return

buyNFTFromMarketplace:
	proto 3 0

	// contracts/algorand_nft_marketplace.algo.ts:100
	// assert(this.order(orderId).value.status === 0)
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 48 8
	btoi
	int 0
	==
	assert

	// contracts/algorand_nft_marketplace.algo.ts:102
	// verifyTxn(payment, {
	//       sender: this.txn.sender,
	//       amount: { greaterThan: this.order(orderId).value.price },
	//       receiver: this.order(orderId).value.owner,
	//     })
	// verify sender
	frame_dig -2 // payment: pay
	gtxns Sender
	txn Sender
	==
	assert

	// verify amount
	frame_dig -2 // payment: pay
	gtxns Amount
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 32 8
	btoi
	>
	assert

	// verify receiver
	frame_dig -2 // payment: pay
	gtxns Receiver
	byte 0x6f // "o"
	frame_dig -1 // orderId: uint64
	itob
	concat
	box_get
	assert
	extract 0 32
	==
	assert

	// contracts/algorand_nft_marketplace.algo.ts:109
	// sendAssetTransfer({
	//       xferAsset: nft,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: 1,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/algorand_nft_marketplace.algo.ts:110
	// xferAsset: nft
	frame_dig -3 // nft: asset
	itxn_field XferAsset

	// contracts/algorand_nft_marketplace.algo.ts:111
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/algorand_nft_marketplace.algo.ts:112
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

abi_route_createApplication:
	int 1
	return

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "createCollection(string)void"
	method "mintNFT(string,string)uint64"
	method "mapNFTdata(asset,uint64)void"
	method "listingNFT(asset,uint64,axfer)void"
	method "unListingNFT(uint64,asset)void"
	method "buyNFTFromMarketplace(uint64,pay,asset)void"
	txna ApplicationArgs 0
	match abi_route_createCollection abi_route_mintNFT abi_route_mapNFTdata abi_route_listingNFT abi_route_unListingNFT abi_route_buyNFTFromMarketplace
	err

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub